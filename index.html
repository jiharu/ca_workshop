<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Autonomous Complexity in Life and Machines</title>
<meta name="description" content="">
<meta name="author" content="Artificial Nature">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<link rel="stylesheet" href="css/basic.css" type="text/css" />
<link rel="stylesheet" href="css/github.css" type="text/css" />

<script src="js/marked.min.js"></script>
<script src="js/highlight.min.js"></script>
<style>

header {
  position:fixed;
  left: 0px;
  top: 0px;

  width:220px;
  padding:10px;
  
  max-height: 100%;
  overflow-y: scroll;
  margin-bottom: 100px;
}

header ul {
  padding-left: 1em;
}

footer {
  width:220px;
  position:fixed;
  left: 0px;
  bottom:0px;
  padding:10px;
  background-color: white;
  font-size: small;
}
#content {
  padding:10px;
  padding-left: 260px; 
  max-width: 920px;
}

@media print, screen and (max-width: 720px) {
  header, footer {
    position:static;
    margin-bottom: 0px;
  }
  #content {
    padding: 5px;
  }
}
</style>
</head>

<body>
<header>
  <h2><b>SJSU Workshop</b><br/>Data+AI+Design</h2>	
  <h4>March 2021</h4>	
  <h3><i>Artificial Natures: Games of Life</i></h3>
  <div id="menu"></div>
</header>
<div id="content"></div>
<footer><a href="https://artificialnature.net/">Artificial Nature [Haru + Graham]</a></footer>


<div style="display: none" id="sourcetext">

# Autonomous Complexity in Life and Machines

![](image/DataAIDesign_Posters-03.jpg)

![](image/student/0.png "19%x19%") ![](image/student/1.png "19%x19%") ![](image/student/2.png "19%x19%") ![](image/student/3.png "19%x19%") ![](image/student/4.png "19%x19%") ![](image/student/5.png "19%x19%") ![](image/student/6.png "19%x19%") ![](image/student/7.png "19%x19%") ![](image/student/8.png "19%x19%") ![](image/student/9.png "19%x19%") ![](image/student/10.png "19%x19%") ![](image/student/11.png "19%x19%") ![](image/student/12.png "19%x19%") ![](image/student/13.png "19%x19%") ![](image/student/14.png "19%x19%") ![](image/student/15.png "19%x19%") ![](image/student/16.png "19%x19%") ![](image/student/17.png "19%x19%") ![](image/student/18.png "19%x19%") ![](image/student/19.png "19%x19%") ![](image/student/20.png "19%x19%") ![](image/student/21.png "19%x19%") ![](image/student/22.png "19%x19%") ![](image/student/23.png "19%x19%") ![](image/student/24.png "19%x19%") ![](image/student/25.png "19%x19%") ![](image/student/26.png "19%x19%") ![](image/student/27.png "19%x19%") ![](image/student/28.png "19%x19%") ![](image/student/29.png "19%x19%") ![](image/student/30.png "19%x19%") ![](image/student/31.png "19%x19%") ![](image/student/32.png "19%x19%") ![](image/student/33.png "19%x19%") ![](image/student/34.png "19%x19%")

Humans have always looked to nature for inspiration. As artists, we have done so in creating a family of “artificial natures”: interactive art installations surrounding humans with biologically-inspired complex systems experienced in immersive mixed reality. The invitation is to become part of an alien ecosystem rich in networks of complex feedback, but not as its central subject. Although artificial natures are computational, we draw our inspiration from the sense of open-ended continuation and the aesthetic integration of playful wonder with the tension of the unfamiliar recalled from childhood explorations in nature.

In our contemporary culture, with new media, the clear line between life and non-life became blurred. The more microscopically we could see life, the more it seemed that the difference from non-life was not the materials, but how they are organized. Cellular Automata (CA) demonstrated clear examples of how non-living machines can give rise to these kinds of emergent behaviors seen in life. A CA is a grid of cells, each of which can be in one or another state, and which follows a very simple set of rules to change its state according to the states of other cells nearby. The CA model is a foundation of fields of Artificial Life, AI, Complexity, as well as the development of modern computers, but also to interdisciplinary and generative art and design practices.

In this workshop we will examine the nature of CAs, their history and how they work. The best way to really understand CAs is by making them. We will build two of the most fascinating examples of emergent cellular automata: John Conway's Game of Life and Christopher Langton's Ants. By doing so we will explore its essential components and how they can lead to precarious, emergent, and resilient systems. 

We will use web-based Javascript editors to make these short lines of scripts together. This code should be intuitive to read and parse, and we will examine how we can alternate it to fit to your design and art expressions. A computer with internet connection is required however, coding experience is not.  

### How can life emerge from non-life?

The question of how life can emerge from non-life is fundamental to understand what life is, but it is a question upon which science can only speculate, as we have no readily available examples of the spontaneous emergence of life for empirical study. However, the problem can be approached more generally through the modeling of the emergence of complex structures that evoke life-like characteristics, from simpler dynamic substrates. 

In this workshop we'll look at this question through the relatively simple model of Cellular Automata (CA). The CA model was propsed by Stanislaw Ulam and used by [von Neumann](https://en.wikipedia.org/wiki/Von_Neumann_universal_constructor) -- in the 1940's -- to demonstrate the possibility of machines that could reproduce themselves. At this time CAs were modeled using pen and paper or with tokens on chessboards, but since the model is discrete in time, space, and states, it is also immediately suitable for computational simulation.

The world of a Cellular Automata is a grid of cells (in one, two, or more dimensions), each of which can be in one or another state (e.g. white or black). Each cell follows a simple set of rules to change its state according to the states of its immediate neighbors.

## Schedule

1. CA Context.  
2. Explorations of Cellular Automata using P5.js 
	- Launch.  
	- Conway’s Game of Life.  
	- Langton's Ant.  
3. Q&A, further discusion.	

### Requirements

Networked computer, notebook/pencil & paper.

_____________________________

# Cellular Automata

The question, "what is life?", may have been easy to answer a long time ago, but not anymore. Once we believed that if we could see the smallest components of life, down to the microscopia, we would understand life. But, what we found is that life & non-life were basically made of the same stuff.

The only difference seems to be in how they are organized (or, rather, how they organize themselves). Life tends to slow down physical processes of entropy, and **complexify** itself into highly unlikely structures and behaviours, by copying and rewriting itself as it interacts with a dynamic environment. In the words of computing pioneer John von Neumann: *"life is a process which can be abstracted away from any particular medium."* And if so, there is no reason to suppose that living systems cannot occur in media that are not part of our natural evolution, including digital media.

**Artificial Life** examines systems related to life, its processes, and its evolution, through the use of simulations with computer models, robotics, and human-made biochemistry. The discipline was named and founded in the 1980's by Christopher Langton. Aspects of Artificial Life research recur in AI, Complexity Science, Bioinformatics, Synthetic Biology, Computer Graphics, Computer-Aided Design and Architecture, etc. 

Rather than taking a specific system and investigating its prinicpal features top-down, Artificial Life tends to work through **bottom-up** approaches, creating simulations in which complex behaviours or other **emergent phenomena** arise from:

- a simple set of rules, and
- a population that follows those rules

Results are emergent in that they are not explicable, or predictable, from the rules themselves -- to some extent they go beyond the author of the system. These characteristics have deep natural synergies with the practices of **Generative Art**.

But the earliest examples of Artifiical Life predate computing machinery. The idea of a **Cellular Automaton** was first proposed by Stanislav Lem to von Neumann in the 1940's as a way to investigate how life may emerge from non-life, and von Neumann used it to demonstrate that an abstract machine could construct something more complex than itself in the same way that living systems can.

## Conway's Game of Life, 1970
22
The most famous CA is probably the Game of Life. It is a 2D automata, which uses a neighbourhood of 8 neighbours, and synchronous update. The transition rule can be stated as follows:

- If the current state is 1 ("alive"):
	- If the neighbor total is less than 2: New state is 0 ("death by loneliness")
	- Else if the neighbor total is greater than 3: New state is 0 ("death by overcrowding")
	- Else: State remains the same ("alive")
- If the current state is 0 ("dead"):
	- If the neigbor total is exactly 3: New state is 1 ("reproduction")
	- Else: State remains the same ("dead")
	
The Game of Life produces easily recognizable higher-level formations including stable objects, oscillatory objects, mobile objects and objects that produce or consume others, for example, which have been called 'ponds', 'gliders', 'eaters', 'glider guns' and so on. 

### Videos

Does John Conway hate his Game of Life?, 6:53

---youtube:E8kUJL04ELA

[An homage in the NY Times](https://www.nytimes.com/2020/12/28/science/math-conway-game-of-life.html)

Stephen Hawkings The Meaning of Life (John Conway's Game of Life segment), 3:29:

---youtube:CgOcEZinQ2I

Computational universality: Turing Machine in the Game of Life:

---youtube:My8AsV7bA94

Game of Life in Game of life

---youtube:xP5-iIeKXE8

		

## Essential CA components

The essential components that define a cellular system are:

- **Cellular space:** A collection of cells arranged into a discrete lattice, such as a 2D grid. The space is usually 1D, 2D or 3D, but rarely greater. 

- **Cell states:** The information representing the current condition of a cell. In binary CAs this is simply either 0 or 1.

- **Initial conditions:** What state the cells are in at the start of the simulation.

- **Neighborhood:** The set of adjacent/nearby cells that can directly influence the next state of a cell. The most common 2D neighborhoods are: 

	![neighborhoods](http://www.economicsnetwork.ac.uk/cheer/ch17/hand1.gif)

- **State transition function:** The rule that a cell follows to update its state, which depends on the current state and the state of the neighborhood. It gives the cell state[t+1] as a function of the states[t] of itself and neighbours. 

	The transition rule always reads from the 'past' lattice, and always writes to the 'future' lattice. After all cells are updated, either the 'future' is copied to the 'past', or the 'future' and 'past' lattices are swapped, since the future of yesterday is the past of tomorrow. 

- **Time axis:** The cells are generally updated in a discrete fashion, which may be synchronous (all cells update simultaneously) or asynchronous (cells update sequentially).

- **Boundary conditions:** What happens to cells at the edges of the space. A periodic boundary 'wraps around' to the opposite edge; a static boundary always has the same state, a reflective boundary mirrors the neighbor state.

### Observations

In the Game of Life, the spatial directions of cells do not matter, only the total value of all neighbors is used, along with the current value of the cell itself. Also the rules of the Game of Life rules mean that the Game of Life is not reversible: from a given state it is not possible to determine the previous state.

### Bottom-up self-organization

The strategy of making possible complex phenomena by the simulation of simple interracting components. In a bottom-up approach the individual base elements of the system are first specified in detail. These elements are then linked together to form larger subsystems, sometimes in many levels, until a complete top-level system is formed. In some cases, this can lead to complex, emergent, and self-organized behaviour.

> "Self-organization is a process where some form of overall order arises from local interactions between parts of an initially disordered system. The process can be spontaneous, not needing control by any external agent. The resulting organization is wholly decentralized, distributed over all the components of the system. As such, the organization is typically robust and able to survive. Chaos theory discusses self-organization in terms of islands of predictability in a sea of chaotic unpredictability. Self-organization occurs in many physical, chemical, biological, robotic, and cognitive systems. Examples of self-organization include crystallization, thermal convection of fluids, chemical oscillation, animal swarming, neural circuits, and black markets." - [Wikipedia](https://en.wikipedia.org/wiki/Self-organization)


### Wolfram's Rule 30

Stephen Wolfram, author of Mathematica, performed extensive research on CAs and uncovered general classes of behaviour comparable to dynamical systems. A commonly referenced example is his 'rule 30', which is a 1D CA displayed below as a stacked trace (history goes down) -- whose pattern is reminiscent of some naturally occurring shell patterns:

![Evolution of a 1D CA: rule 30](image/ca_shells.jpg)  

![Rule 30](image/rule30.png)

- [Elementary CA - mathworld.wolfram.com](http://mathworld.wolfram.com/ElementaryCellularAutomaton.html)  

- [Computing a theory of everything | Stephen Wolfram, TED](https://www.youtube.com/watch?v=60P7717-XOQ)  

---codepen:https://codepen.io/Hrrr/pen/MOJmwL?editors=0010

### Four CA classes

Wolfram divided CA into four classes, according to their long-term behavior:

- **Class 1:** Evolve to a fixed and homogeneous state.
- **Class 2:** Evolve to simple periodic configurations (limit cycles).
- **Class 3:** Evolve to chaotic patterns 
- **Class 4:** Evolve to complex patterns of localized structures with long transients.  
 
Conway’s Game of Life is a class 4 CA. 

## Beyond the Game of Life

---youtube:ISQChKRH4NI

[SmoothLife](http://www.youtube.com/playlist?list=PL69EDA11384365494) uses a discrete grid, but all of states, kernel, and transition functions are adjusted for smooth, continuous values. A disc around a cell's center is integrated and normalized (i.e. averaged) for the cell's state, and a ring surrounding this is integrated & normalized (averaged) for the neighbor state. Cell transition functions are expressed in terms of continuous sigmoid thresholds over the [0, 1] range, and re-expressed in terms of differential functions (velocities of change) to approximate continuous time. [Paper here](http://arxiv.org/pdf/1111.1567v2.pdf). By doing so, it removes the discrete bias and leads to fascinating results. [Another implementaton](http://www.youtube.com/watch?v=l7t8LtdBAV8). [Taken to 3D](http://www.youtube.com/watch?v=zA857JdUn9o&list=PL69EDA11384365494&index=46). In effect, by making all components continuous, it is essentially a simulation of differential equations. [Here is a great explanation of the SmoothLife implementation, with a jsfiddle demo](http://0fps.net/2012/11/19/conways-game-of-life-for-curved-surfaces-part-1/)


### Lenia

Lenia continues in the spirit of SmoothLife, and has been extensively explored & documented to identify over 400 different organisms, occuping distict environmental niches (different physical constants), with various locomotive patterns catalogued, etc.

[https://player.vimeo.com/video/277328815]()

- [Paper](https://arxiv.org/abs/1812.05433)
- [Code](https://github.com/Chakazul/Lenia)
- [Winner in Virtual Creatures Contest, GECCO 2018, Kyoto](https://virtualcreatures.github.io/)
- [Honorable Mention in ALife Art Award, ALIFE 2018, Tokyo.](http://artaward2018.alifelab.org/)

----

## Langton's Ant, 1986

[Langton's Ant](http://en.wikipedia.org/wiki/Langton%27s_ant) is a mobile CA in a 2D, two-state space, with a very definition. A cellular space (a 2D grid) of black or white cells is inhabited by one or more ants. These ants face one of four possible directions (north, east, south, or west) and move one cell at a time, following a very simple rule:
- at a white square, turn 90° right, flip the color of the square, move forward one unit
- at a black square, turn 90° left, flip the color of the square, move forward one unit

- [Langton's Ant (and Life)](http://datagenetics.com/blog/september22015/index.html)

- [Langton's Ant](http://en.wikipedia.org/wiki/Langton%27s_ant) is a mobile CA in a 2D, two-state space, with very simple rules:
		
The original video by Christopher Langton, including examples of multiple ants (and music by the Vasulkas):

---youtube:w6XQQhCgq5c

Christopher Langton also proposed a more concise self-reproducing CA than von Neumann's, which has since been further improved upon using artificial evolutionary techniques:

- [Langton's Loops, 3:35](https://www.youtube.com/watch?v=2iDc4C6vbcc) 

## More CAs

**Langton's Ant** multiple ants:

---codepen:https://codepen.io/grrrwaaa/pen/LMJwVP

**Brian's Brain** 3-state CA:

---codepen:https://codepen.io/grrrwaaa/pen/JwaQqV

**Forest Fire** probabilistic CA:

---codepen:https://codepen.io/grrrwaaa/pen/OroeKW

**String Thing** block rule CA:

---codepen:https://codepen.io/grrrwaaa/pen/NGxJpP

**Hodge-Podge** contact process model:

---codepen:https://codepen.io/grrrwaaa/pen/bOxXEo

**Ising model**:

---codepen:https://codepen.io/grrrwaaa/pen/wREVKe

**Gray-Scott** reaction-diffusion model:

---codepen:https://codepen.io/grrrwaaa/pen/roZXmR


### Continuous automata

The CAs are mostly discrete, and this is often evident in the results. But there are several ways to approximate fully continuous automata -- and investigate to what extent similar properties or behaviours arise, and whether new properties can arise unique to continuous spaces. At the least, continuous automata are more able to show liquid and diffusive effects:

#### Smoothlife

- [Generalized Conway Game of Life - SmoothLife1](https://www.youtube.com/embed/ISQChKRH4NI?list=PL69EDA11384365494)

### Reaction Diffusion

The reaction-diffusion model was proposed by Alan Turing to describe embryo development and pattern-generation ([Turing, A. The Chemical Basic for Morphogenesis.](http://www.dna.caltech.edu/courses/cs191/paperscs191/turing.pdf)); it is still used today in computer graphics ([Greg Turk's famous paper](http://www.cc.gatech.edu/~turk/my_papers/reaction_diffusion.pdf)). RD systems and other differential equation systems can be approximated using continuous automata.

- [Reaction-Diffusion "Coral Growth" Example](https://www.youtube.com/embed/8dTmUr5qKvI?rel=0)  
One approach to simulating RD using CA is the *Gray-Scott* model, as described in [Pearson, J. E. Complex Patterns in a Simple System](http://arxiv.org/pdf/patt-sol/9304003.pdf). A browser-based example is [here](https://pmneila.github.io/jsexp/grayscott/).


_____________________________

# Using P5.js

> "p5.js is a JavaScript library for creative coding, with a focus on making coding accessible and inclusive for artists, designers, educators, beginners, and anyone else! p5.js is free and open-source because we believe software, and the tools to learn it, should be accessible to everyone. Using the metaphor of a sketch, p5.js has a full set of drawing functionality." -[https://p5js.org/]()

P5.js is a browser-based javascript creative coding platform that inherits most of its design from the Processing language, one of the widely-used creative coding platforms of the last decades, itself directly inspired by John Maeda's "Design By Numbers" project at the MIT Media Lab.

To create "sketches" using P5.js, it's convenient to use an online, browser-based editor. There are lots of online javascript editors and previewers available. We like to use the **Codepen** editor, but we'll also introduce the **P5 Editor** as an alternative too.

## Codepen

> "CodePen is a playground for the front end side of the web. Need to build a reduced test case to demonstrate and figure out a bug? CodePen is great for that. Want to show off your latest creation and get feedback from your peers? CodePen is great for that. Want to find examples of a particular design pattern for your project? CodePen is great for that." - [codepen.io](https://codepen.io/about/)  

To use Codepen you need to do two things:

1. Make sure you have a good recent web browser to use, such as Firefox or Chrome.
2. Create a free account: [codepen link](https://codepen.io/)

To set up a new sketch, or "pen", for this workshop you have two options:

### Option 1: Fork our template pen

- Open the following link in a new browser window: [https://codepen.io/grrrwaaa/pen/LYbgyyx?editors=0010]() 
- Click on the **Fork** button at the bottom-right to make a new copy of it,
- Then press **Save** to save it into your account.

### Option 2: Create and configure a new pen

You can create a pen by pressing "Pen" under "Create" on the top left of the main Codepen page.

To work with P5.js we need to add the P5.js library to the pen:

- Open the **Settings** at the top of the screen, and select the **JS** settings. 
  - Under **Add External Scripts**, find the box with *Search CDNjs* and type "p5". It should offer a full URL for the p5 library, which you can click or press enter to select
  - Alternatively: You can copy the following address and paste it into the box underneath the one saying *Search CDNjs*: https://cdnjs.cloudflare.com/ajax/libs/p5.js/0.7.2/p5.min.js
- Click **Save & Close**

![codepen](image/codepen01.png)  

### Quick Test

Let's quickly test to make sure you have it working. 

There are three text boxes in the editor, for entering code in **HTML**, **CSS**, and **JS** (Javascript). We'll only be using the JS box so we can stretch this box to be large to have more space. Paste the following code into the **JS** box:

```javascript
function setup() {  
  // initialize the canvas & graphics state:  
  createCanvas(windowWidth, windowHeight);  
  background(128);
}
```

- If you see the screen change its color to grey, you know that you're ready:
  	
![codepen](image/codepen02.png)  
  	
*Yeah~ Successful!*

You may also want to open the browser console, where any errors will be printed. How to do this depends on what browser you use. E.g. in Chrome, it is under View / Developer > JavaScript Console. In Firefox it is Tools / Web Developer > Browser Console. [For other browsers see here.](https://webmasters.stackexchange.com/questions/8525/how-do-i-open-the-javascript-console-in-different-browsers)

### Extra options

- You can copy & paste the following code to the **CSS** box to get rid of borders and scroll bars around your canvas:

```css
/* these styles remove the space & scrollbars around the canvas */  
body {margin:0; padding:0;}  
canvas {display:block;} 		
```

- You can disable Auto-Updating Preview under Behavior in the **Settings** box. The Run button will appear at the top right pannel. (Sometimes auto-updating can be distracting, and manually pressing Run can be better.)

- To know more Codepen options see the [Codepen documentation](https://blog.codepen.io/documentation/) 

### P5 Editor

As an alternative to Codepen you can use the p5.js Web Editor. It is free and open source, no sign up, setup, or download required: [p5.js Web Editor](https://editor.p5js.org/)  

## P5.js

- P5 documentation: [https://p5js.org/download/](https://p5js.org/download/)
	
Generally, a P5.js script will have these main sections:

```js
// Global declarations
// declare global variables that can be used in any function
// and persist through the program's lifetime

// setup() runs once when the program starts
// use it to define the canvas
// and initialize the global state
function setup() {
  // create a p5.js canvas that fills the available area:
  canvas = createCanvas(windowWidth, windowHeight);
  // do other initialization here
}

// the draw() function is called repeatedly
// about 60 times a second (if the computer is fast enough)
function draw() {
  // do animated drawing here
}
```

_____________________________

## Game of Life

To draw the Game of Life, we'll need to draw black and white squares. Here's the P5 code fragments we'll need:

- Set up drawing style:
  - `background(0) // black background`
  - `noStroke() // don't draw borders around shapes`
- Set a colour and draw a square (in pixels)
  - `fill(255) // white`
  - `fill(0) // black`
  - `cell_size = 8 // (global) cell size in pixels`
  - `rect(10, 20, cell_size, cell_size) // x, y, width, height`

The next thing we need to know is how many rows and columns of cells there should be.
If the `cell_size` is 8, then the number of columns is the `width` of the canvas divided by 8. And similarly, the number of rows is `height/cell_size`. 

We need to use `rows` and `columns` everywhere in the script, so we have to declare them in the global section at the start, but we can't actually set their values until we have created the canvas (because until that point, we don't know how big the canvas is), so that part has to go into `setup()`:

```js
// global declarations
var cell_size = 8;  // (global) cell size in pixels
var rows;           // determined in setup()
var columns;        // determined in setup()

function setup() {
  // create a p5.js canvas that fills the available area:
  canvas = createCanvas(windowWidth, windowHeight);
  // creating the canvas defines `width` and `height`
  // use this to figure out how many rows & columns we have:
  rows = width / cell_size;
  columns = height / cell_size;
}
```

Let's try drawing a random cell. 

P5.js has a function called `random(n)` which will give you a random number from 0 to `n`. However this number will have a decimal part (programmers call this a "floating point" number). If we want a whole number (what programmers call an "integer"), we have to round it down. We can do that using `floor()`. So, to pick a random row and column:

```js
var r = floor(random(rows));
var c = floor(random(columns));
```

In the Game of Life a cell can either be dead (value is zero) or alive (value is one), which we can call the state. To draw white in P5.js we need to set `fill(255)` so we can do this from a cell state, and draw our cell, like this:

```js
var r = floor(random(rows));
var c = floor(random(columns));
var state = floor(random(2)); // 0 or 1, dead or alive
fill(state * 255); // 0 or 255, black or white
// draw rect at x, y, width, height:
rect(r * cell_size, c * cell_size, cell_size, cell_size);
```

> Try putting this code into the `draw()` function rather than in `setup()`!

What if we want to fill the *entire* field all at once, rather than frame by frame? We'll need to **loop** over each row, and for each one, again **loop** over each column, to set each cell in turn:

```js
for (let r = 0; r < rows; r++) {
  for (let c = 0; c < columns; c++) {
    var state = floor(random(2)); // 0 or 1, dead or alive
    fill(state * 255); // 0 or 255, black or white
    // draw rect at x, y, width, height:
    rect(r * cell_size, c * cell_size, cell_size, cell_size);
  }
}
```

---

The next step is to add **memory**. The state of the cells in one frame depends on the state of the cells on the frame before (through the neighbourhood). So we need a way to setup the states of cells initially, and use those states on every frame. In Javascript we can create lists (using `[]`) which programmers call "Arrays". We can create a list of rows, where each row is another list of all the cell states. The game is a list of lists.

```js
// global declarations
// cells is defined as an empty array
// (this will become a "2D" array -- an array of arrays):
let cells = [];

function setup() {
  //...

  for (let r = 0; r < rows; r++) {
    // create a new row (array of arrays):
    cells[r] = [];
    // for each column in this row:
    for (let c = 0; c < columns; c++) {
      // create a new cell
      // state is either 0 or 1
      cells[r][c] = floor(random(2));
    }
  }
}

function draw() {
  // loop over the rows & columns of the cells
  // to draw each one
  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < columns; c++) {
      // get the state of this location in the cells array:
      let cell = cells[r][c];
      // scale state (0,1) up to greyscale range (0,255):
      fill(cell * 255);
      // draw a box at this cell's location and size:
      rect(c * cell_size, r * cell_size, cell_size, cell_size);
    }
  }
}
```

--- 

We are **almost** ready now to insert the Game of Life rules. But there's a catch. The states of the whole grid must update synchronously. That means: when one cell changes, all cells should change. This is not easy to achieve in most computing systems today, which mostly follow instructions one at a time (with only limited parallelism). A naive implementation will thus update cells one at a time, and the neighborhood of a particular cell will contain both 'past' and 'future' states. One way to work around this is to maintain two copies of the grid; one for the 'past' states, and one for the 'future' states. The transition rule always reads from the 'past' lattice, and always writes to the 'future' lattice. After all cells are updated, the 'future' grid is copied to the 'past' grid, since the future of yesterday is the past of tomorrow.

> This technique is called double-buffering, and is widely used in software systems where a parallel process interacts with a serial machine. It is used to render graphics to the screen, for example.

To do this in our script, we just add a second array, which we can call `newcells`:


```js
// global declarations
// cells is defined as an empty array
// (this will become a "2D" array -- an array of arrays):
let cells = [];
// we also need a second 2D array for the next generation
// (at each frame we calculate new cell values and store them in newcells
// and then swap cells and newcells for the next frame)
let newcells = [];

function setup() {
  //...

  for (let r = 0; r < rows; r++) {
    // create a new row (array of arrays):
    newcells[r] = [];
    cells[r] = [];
    // for each column in this row:
    for (let c = 0; c < columns; c++) {
      // create a new cell
      // state is either 0 or 1
      newcells[r][c] = floor(random(2));
      // make sure to also create the old cells:
      cells[r][c] = 0
    }
  }
}

function draw() {
  // loop over the rows & columns of the cells
  // to draw each one
  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < columns; c++) {
      // get the state of this location in the cells array:
      let cell = newcells[r][c];
      // scale state (0,1) up to greyscale range (0,255):
      fill(cell * 255);
      // draw a box at this cell's location and size:
      rect(c * cell_size, r * cell_size, cell_size, cell_size);
      // update the old cells array with the new cell value:
      // (if we didn't do this, the CA would not continuously update)
      cells[r][c] = cell;
    }
  }
}
```

----

Now, finally, we have everything we need to add the Game of Life. On every frame (that is, in `draw()`), we want to loop over each cell of `newcells` and set its new state according to the states of that location, and its neightbours, in the older `cells` array. That means another loop of loops over the grid.

For the cell at `cells[r][c]`, the neighbour to the West is `cells[r-1][c]`, and so on for East, North, South, etc.

```js
// get each of the neighbouring cells (from the previous generation):
let N  = cells[r-1][c  ];
let S  = cells[r+1][c  ];
let W  = cells[r  ][c-1];
let E  = cells[r  ][c+1];
let NE = cells[r-1][c+1];
let SE = cells[r+1][c+1];
let NW = cells[r-1][c-1];
let SW = cells[r+1][c-1];
```

We need to be careful though: when `r` is 0, then the neighbour location to the left would be `-1`, and there's no neighbour there. So we need some special handling to take care of those **boundary** cases. Probably the easiest solution is to say that all boundary cells are always dead, or never change, or always randomize:

```js
if (c <= 0 || c >= columns - 1 || r <= 0 || r >= rows - 1) {
  // some options:
  // let border cells be always dead
  newcells[r][c] = 0;
  // or, let border cells stay the same
  //newcells[r][c] = cell;
  // or, let border cells be always randomized:
  //newcells[r][c] = floor(random(2));
} else {
  // get each of the neighbouring cells (from the previous generation):
  let cell = cells[r][c];
  let N  = cells[r-1][c  ];
  let S  = cells[r+1][c  ];
  let W  = cells[r  ][c-1];
  let E  = cells[r  ][c+1];
  let NE = cells[r-1][c+1];
  let SE = cells[r+1][c+1];
  let NW = cells[r-1][c-1];
  let SW = cells[r+1][c-1];
  //...
}
```
Now, finally, we can compute the number of living neighbours, and use this to implement the Game of Life rules to update `newcells[r][c]` accordingly:

- If the current state is 1 ("alive"):
	- If the neighbor total is less than 2: New state is 0 ("death by loneliness")
	- Else if the neighbor total is greater than 3: New state is 0 ("death by overcrowding")
	- Else: State remains the same ("alive")
- If the current state is 0 ("dead"):
	- If the neigbor total is exactly 3: New state is 1 ("reproduction")
	- Else: State remains the same ("dead")
	

```javascript

// declare global variables,
// that can be used in any function
// and persist through the program's lifetime:

// cell size in pixels:
let cell_size = 8;
// number of cells in each dimension
// (depends on cell_size and canvas size):
let columns, rows;

// cells is defined as an empty array
// (this will become a "2D" array -- an array of arrays):
let cells = [];
// we also need a second 2D array for the next generation
// (at each frame we calculate new cell values and store them in newcells
// and then swap cells and newcells for the next frame)
let newcells = [];

// setup() runs once when the program starts
// use it to define the canvas
// and initialize the global state
function setup() {
  // create a p5.js canvas that fills the available area:
  canvas = createCanvas(windowWidth, windowHeight);
  // initialize graphics: black background, no borders:
  background(0);
  noStroke();
  
  // number of cells in each dimension
  // (depends on cell_size and canvas size):
  columns = width/cell_size;
  rows = height/cell_size;
  
  // initialize the 2D arrays of cells and newcells:
  // first create a list of rows:
  
  for (let r = 0; r < rows; r++) {
    // create a new row (array of arrays):
    cells[r] = [];
    newcells[r] = [];
    // for each column in this row:
    for (let c=0; c < columns; c++) {
      // create a new cell
      // state is either 0 or 1
      cells[r][c] = floor(random(2));
      // newcells starts off identical to cells:
      newcells[r][c] = cells[r][c];
    }
  }
}

// the draw() function is called repeatedly
// about 60 times a second (if the computer is fast enough)
function draw() {
  
  // compute the new generation as 'newcells'
  // by reading from the states in 'cells':
  // row by row, column by column:
  for (let r = 0; r < rows; r++) {
    // for each column in this row:
    for (let c=0; c < columns; c++) {
      // get this cell's current state:
      let cell = cells[r][c];
      
      // special case for border cells:
      // i.e. where the cell's row is 0 or (rows-1)
      // or the cell's column is 0 or (columns-1)
      // these cells do not have a full neighbourhood
      if (c <= 0 || c >= columns-1 || r <= 0 || r >= rows-1) {
        // some options:
        // let border cells be always dead
        newcells[r][c] = 0;
        // or, let border cells stay the same
        //newcells[r][c] = cell;
        // or, let border cells be always randomized:
        //newcells[r][c] = floor(random(2));
      } else {
        // not a border cell
        
        // get each of the neighbouring cells (from the previous generation):
        let N  = cells[r-1][c  ];
        let S  = cells[r+1][c  ];
        let W  = cells[r  ][c-1];
        let E  = cells[r  ][c+1];
        let NE = cells[r-1][c+1];
        let SE = cells[r+1][c+1];
        let NW = cells[r-1][c-1];
        let SW = cells[r+1][c-1];
        // add them up:
        let sum = N + S + E + W + NE + SE + NW + SW;
        
        // Game of life rules:
        if (cell) {
          // cell is 'alive'
          if (sum < 2 || sum > 3) {
            // death by loneliness or overcrowding
            newcells[r][c] = 0;
          } else {
            // staying alive
            newcells[r][c] = 1;
          }
        } else {
          // cell is 'dead'
          if (sum == 3) {
            // three neighbors, trisexual reproduction:
            newcells[r][c] = 1;
          } else {
            // stay 'dead'
            newcells[r][c] = 0;
          }
        }
      }
    }
  }
  
  // now do another loop to draw it, updating cells as we go:
  for (let r = 0; r < rows; r++) {
    for (let c=0; c < columns; c++) {
      // get the state of this location in the newcells array:
      let cell = newcells[r][c];
      // scale state (0,1) up to greyscale range (0,255):
      fill(cell * 255);   
      // draw a box at this cell's location and size:
      rect(c*cell_size, r*cell_size, cell_size, cell_size);
      // update the old cells array with the new cell value:
      // (if we didn't do this, the CA would not continuously update)
      cells[r][c] = cell;
    }
  }
}

```


### The coding train tutorial

- [The Game of Life - The Nature of Code by The coding train.](https://www.youtube.com/watch?v=tENSCEO-LEc)  	
	
---

## Langton's Ant

The basic definition of a cellular grid can use the same code as with Game of Life. However, this time the cells don't update synchronously (they are changed by the ants instead), so we don't need `newcells`. 

The initial state of the grid is not randomized as in the Game of Life, but is set to all-white or all-black.

We also need to define an "ant". The ant persists over time, so this should be declared globally. The ant is an object with several properties: a position (row & column) and a direction (N, E, S or W).

```js
// global:
var ant;

  // in setup()
  // initialize the ant
  ant = {
    // start location:
    x: floor(columns / 2),   // or floor(random(columns))
    y: floor(rows / 2),      // or floor(random(rows))
    // with a random heading:
    // ants can only face north, east, south, or west
    // we can encode these directions as 0, 1, 2, 3:
    direction: floor(random(4))
  };
```

We can draw the ant in a different colour so we can see where it is;

```js
  // at the end of draw()
  // draw the ant:
  fill("red");
  rect(ant.x * cell_size, ant.y * cell_size, cell_size, cell_size);
```

To make the ant move, we adjust the location on each frame according to the ant's direction:

```js
  if (ant.direction == 0) {
    // North:
    ant.y--;
  } else if (ant.direction == 1) {
    // East:
    ant.x++;
  } else if (ant.direction == 2) {
    // South:
    ant.y++;
  } else if (ant.direction == 3) {
    // West:
    ant.x--;
  }
```

To stop it wandering off, we can wrap it around the edges of the world, like Pac-Man:

```js
  // if we hit the edge of the canvas, wrap around:
  if (ant.direction == 0) {
    // North:
    ant.y--;
    if (ant.y < 0) ant.y += rows;
  } else if (ant.direction == 1) {
    // East:
    ant.x++;
    if (ant.x >= columns) ant.x -= columns;
  } else if (ant.direction == 2) {
    // South:
    ant.y++;
    if (ant.y >= rows) ant.y -= rows
  } else if (ant.direction == 3) {
    // West:
    ant.x--;
    if (ant.x < 0) ant.x += columns;
  }
```

Now we are ready to add the Ant's rule: 

- at a white square, turn 90° right, flip the color of the square, move forward one unit
- at a black square, turn 90° left, flip the color of the square, move forward one unit

This should be inserted *before* the ant moves:

```js
  // the ant's rules depend on the state of the cell it stands on:
  let cell = cells[ant.y][ant.x];

  // if the cell is white:
  if (cell) {
    // turn clockwise:
    ant.direction--;
    // make sure the direction is still in the range 0, 1, 2, 3:
    if (ant.direction < 0) ant.direction += 4;
  } else {
    // turn anti-clockwise:
    ant.direction++;
    // make sure the direction is still in the range 0, 1, 2, 3:
    if (ant.direction > 3) ant.direction -= 4;
  }
  // now flip the square color to black:
  cells[ant.y][ant.x] = 0;
```

That's it! 

---

Things can get interesting if you speed this up. We can wrap the whole ant-update routine in another "for loop" to make the ant move many times per frame. Try running 10, 100, or even 1000 times per frame, and see what happens! 


```js
  // run many ant-simulation steps per frame
  for (var i=0; i < 10; i++) {
    // put ant cell rule here
    // put ant move code here
  }
  // put drawing code here
```

Things can also get interesting when more than one ant lives in the world. We can alloate a list (array) of ants globally, and set up each ant's position and direction as we prefer. Then we loop over the list of ants to run them all.

```js
// global
var ants = [];

  // in setup():
  ants[0] = {
    x: floor(columns/2),
    y: floor(columns/2),
    direction: 0
  }
  ants[1] = {
    x: floor(columns/2),
    y: floor(columns/2),
    direction: 1
  }


  // in draw():
  for (var i=0; i < ants.length; i++) {
    var ant = ants[i];

    // put ant cell rule here
    // put ant move code here
  }

  // put cells drawing code here

  for (var i=0; i < ants.length; i++) {
    var ant = ants[i];

    // put ant drawing code here
  }
```


## Rule 30

```javascript
// declare global variables,
// that can be used in any function
// and persist through the program's lifetime:
let columns, rows, generation;
// cells is defined as an empty array:
let cells = [];

// setup() runs once when the program starts
// use it to define the canvas
// and initialize the global state
function setup() {
  // create a p5.js canvas that fills the available area:
  canvas = createCanvas(windowWidth, windowHeight);
  // initialize graphics: black background, no borders:
  background(0);
  noStroke();

  // define number of rows & columns by pixel dimensions:
  columns = floor(windowWidth);
  rows = floor(windowHeight);
  // initialize the simulation data:
  reset();
}

function reset() {
  // set each cell to a random initial value:
  for (let i = 0; i < columns; i++) {
    // random(2) picks a decimal number greater than or equal to zero, and less than 2.
    // floor() rounds this down to the nearest whole number
    // so the result is either exactly 0 or 1:
    cells[i] = floor(random(2));
  }
  // start at the zeroth generation:
  generation = 0;
}

// the draw() function is called repeatedly
// about 60 times a second (if the computer is fast enough)
function draw() {
  // draw each cell:
  for (let i = 0; i < columns; i++) {
    // get the current cell
    let cell = cells[i];
    // draw it
    // set the paint color to black (0) or white (255)
    // according to the cell value
    fill(cell * 255);
    // draw a box, at the cells's column,
    // at the current generation's row,
    // of size 1 pixel by 1 pixel
    rect(i, generation, 1, 1);
  }

  // increment the current generation count:
  generation++;
  // if we haven't yet filled the screen:
  if (generation < rows) {
    // compute a new generation:
    // create a new array to hold the next generation of cells
    // (need to make a new array, rather than modifying in place,
    // so that cells and neighbours properly update in parallel)
    let newcells = [];
    // compute each new cell value:
    for (let i = 0; i < columns; i++) {
      // get the current cell, and its left and right neighbours:
      let left = cells[i - 1];
      let center = cells[i];
      let right = cells[i + 1];
      // call the rule() function to determine the new cell value:
      newcells[i] = rule(left, center, right);
    }
    // replace the "cells" variable with the new generation
    // to be used on the next frame:
    cells = newcells;
  } else {
    // else if we *have* filled the screen,
    // reset the simulation:
    reset();
  }
}

// returns a new cell state according to a neighborhood
// of three input cells
function rule(left, center, right) {
  // it is possible that the left or right neighbour are undefined
  // (this happens at the left-most and right-most boundaries of the array
  if (left == undefined) {
    // the left-most cell has no left neihbour,
    // so return the state unchanged:
    return center;
  } else if (right == undefined) {
    // the right-most cell has no right neihbour,
    // so return the state unchanged:
    return center;
  } else if (left == 1 && center == 1 && right == 1) {
    return 0;
  } else if (left == 1 && center == 1 && right == 0) {
    return 1;
  } else if (left == 1 && center == 0 && right == 1) {
    return 0;
  } else if (left == 1 && center == 0 && right == 0) {
    return 1;
  } else if (left == 0 && center == 1 && right == 1) {
    return 1;
  } else if (left == 0 && center == 1 && right == 0) {
    return 0;
  } else if (left == 0 && center == 0 && right == 1) {
    return 1;
  } else if (left == 0 && center == 0 && right == 0) {
    return 0;
  }
}
```

---

## Student works

- [Creative coding: Cellular Automata](https://ocaduniversity-my.sharepoint.com/:p:/g/personal/3166051_ocadu_ca/EROKoR9kDUVAsXDRLe4Kv1MBjKSYgVgpCHd-V5zDVIKB-Q?e=V1m8Pp)  This collection of CA alternations are from the class Atelier 1: Discovery and its 2nd module Endless Forms Most Beautiful instruted by Haru Ji in Fall 2020. 

- [Randomized gallery of artificial life experiments](https://artificialnature.net/courses/datt4950/gallery/index.html). This collection of works from "DATT4950: Artificial Life, Generative Art and Creative Code" instructed by Graham Wakefield since 2015.



</div>


<script type="text/javascript">

  var renderer = new marked.Renderer();

  var toc = []
	var heading = renderer.heading.bind(renderer);
	renderer.heading = function(text, level, ...args) {
		var html = heading(text, level, ...args)
		var match = /id="(.+)"/gm.exec(html)
		if (match && match.length > 1) {
			toc.push({
				level: level,
				text: text,
				id: match[1],
			})
		}
		return html
	}
  renderer.image = function(href, title, text) {  
    if (title) {                                                                                                              
        var size = title.split('x');                                                                                          
        if (size[1]) {                                                                                                        
            size = 'width=' + size[0] + ' height=' + size[1];                                                                 
        } else {                                                                                                              
            size = 'width=' + size[0];                                                                                        
        }                                                                                                                     
    } else {                                                                                                                  
        size = '';                                                                                                            
    }                                                                                                                         
    return ('<img src="' + href + '" alt="' + text + '" ' + size + '>');                                                      
  };
	marked.setOptions({
		renderer: renderer,
		highlight: function(code, lang) {
			return hljs.highlight(hljs.getLanguage(lang) ? lang : 'plaintext', code).value;
		},
	});

  
  var source = document.getElementById("sourcetext").innerText;
  source = source.replace(/\n---codepen:https?:\/\/codepen.io\/+([^\/]+)\/pen\/([^\/\n]+)\/?/g, '<p class="codepen" data-height="520" data-default-tab="js,result" data-user="$1" data-slug-hash="$2" data-preview="true"><span><a href="https://codepen.io/$1/pen/$2">Open pen.</a></span></p>');

  source = source.replace(/\n---youtube:([^\s]+)/g, '<iframe width="720" height="540" src="https://youtube.com/embed/$1" frameborder="0" allowfullscreen></iframe>');

  var html = marked(source);

  console.log(toc)
  var menu = [];
  for (var i=0; i<toc.length; i++) {
    var item = toc[i];
    if (item.level <= 2) {
      menu.push( "  ".repeat(item.level-1) + "- [" + item.text + "](#" + item.id + ")" );
    }
  }
  // convert markdown menu to html:
  menu = marked(menu.join("\n"));

  document.getElementById("content").innerHTML = html;
  document.getElementById("menu").innerHTML = menu;
  </script>
<script async src="https://static.codepen.io/assets/embed/ei.js"></script>
</body>
</html>